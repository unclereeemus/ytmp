#!/bin/sh
# YTMP: a shell script for searching, playing, downloading, and keeping track of music from youtube and local files with extensive queue management using fzf, vim, or cli
# DEPS: yt-dlp, mpv, socat, fzf, xargs, find, sed, bc, ed, coreutils, (pipe-viewer for playlist search), (notify-send for notifications), (curl for thumbnails), (n/vim)

[ -z "$prefix" ] && prefix="/home/$USER/Music/ytmp"
conf="$prefix/conf"

[ -e "$conf" ] && . "$conf"

# A value of 1 means true and 0 means false
# for the following settings:
# daemonize, notifications, download_thumbnails, download_songs

# if to play one song after another by default
[ -z "$daemonize" ] && daemonize="1"

# if to download songs after they are played more than $max_stream_amount
[ -z "$download_songs" ] && download_songs="1"
# maximum amount of times to stream a song before downloading it
[ -z "$max_stream_amount" ] && max_stream_amount=3
# the maximum a length a file can be (in seconds) if it's to be downloaded
[ -z "$max_len_for_dl" ] && max_len_for_dl='600'

[ -z "$download_thumbnails" ] && download_thumbnails="0" # 1=true; 0/anything else=false
[ -z "$notifications" ] && notifications="1" # 1=true; 0/anything else=false

[ -z "$dl_dir" ] && dl_dir="$prefix/downloads"
[ -z "$songs_dir" ] && songs_dir="$dl_dir/songs"
[ -z "$thumb_dir" ] && thumb_dir="$dl_dir/thumbnails"
[ -z "$played_urls" ] && played_urls="$prefix/played_urls"
[ -z "$played_artists" ] && played_artists="$prefix/played_artists"
[ -z "$played_titles" ] && played_titles="$prefix/played_titles"
[ -z "$search_history" ] && search_history="$prefix/search_history"
[ -z "$queue" ] && queue="$prefix/queue"

# this is run on everytime a song is played so if you want certain
# mpv settings to remain consistent (volume, loop, seek, etc), then put them in this file
[ -z "$run_on_next" ] && run_on_next="/home/$USER/Music/ytmp/run_on_next"

mkdir -p "$prefix" "$dl_dir" "$songs_dir" "$thumb_dir"

# regex to match what's currently playing
# note: options for ERE are not passed to sed or grep so ERE must be escaped
# also note that ERE might not be available for posix implementation of these utilities

# regex to match <id> ***
playing_marker_regex="^\(.\{11,12\}\) \(\*\*\*\)"

# regex to match what's playing with groups
playing_regex="^\(.\{11,12\}\) \(\*\*\*.*\*\*\*\)$"

# regex for the <id> and <title> fields of any entry
field_regex="^\(.\{11,12\}\) \(.*\)"

# line seperator for preview windows / stdout msgs
lsp='................................\n'

qdiscards_file="/tmp/ytmpqdiscards"

helper () {
cat << CAT_EOF
Usage: ytmp [z] [<search>]/s|x [# of results]/sp <search>/a <local path|dir|url>/e #
       OR v/ls/m [p|l|m|#[+|-#]] [p|l|m|#[+|-#]] [s #|v]/E
       OR -l/-p OR n/p/pl/pf/mln/mfn/l [#|s]/P OR -r/-d

On first installing ytmp, there won't be any history to select from when you enter ytmp
so either pass arguements from the cli with ytmp [z] <search> or to search what's on the
fzf input field press ctrl-x or to background search press ctrl-s / ctrl-z
(difference explained below)

The difference between s and x/z: x/z searches without the added jargon 'auto-generated
provided to youtube' which usually fetches results from youtube music. If you just pass
the query from the command line or just run ytmp without options, it will add the jargon
to your search. ytmp and ytmp z also accept arguements as search if you don't want to
enter fzf for search.

  [no arg] 	enter fzf to make a search with the jargon appended.
  [<search>] 	search with the jargon.
  z [<search>] 	search without the jargon. if no args then enter fzf.

  s [<# of results>]
  		search with the jargon. view search results and select (can select multiple).
		can specify amount of search results to return with a following arguement;
		defaults to 5.

  x [<# of results>]
  		search without the jargon. view search results and select (can select multiple).
		can specify amount of search results to return with a following arguement;
		defaults to 5.

  sp <search> 	search for playlists (requires https://github.com/trizen/pipe-viewer/); bindings:

  a 		add urls (direct links/playlists), paths, or directory
  		(pass them as arguement - accepts many of all the kinds mentioned).
		does not check if file is a media file or not before adding.

  -p 		toggle playback
  -l 		loop what's currently playing
  -ff <secs>	seek forward <seconds>
  -bb <secs>	seek backward <seconds>

  l [n|s] 	play the song that was played before this one or n before this one or
		pass s to select from the history file with fzf.
		single fzf binding: ctrl-o: open entry in web browser.

  w 		toggle mpv window. don't press q to close the window because that will close
  		the file as well instead run ytmp w again to close it.

  mfn 		queue last entry to play next
  mln 		queue last entry to play next
  e 		play entry #; can specify relative places with p|l|m like 'm'
  pf 		play first entry
  pl 		play last entry
  n 		play next on queue
  p 		play prev on queue
  P <search> 	fuzzy search string in queue and play match

  v 		view queue
  vv 		view queue with fzf preview of details about the song

  ls 		show a numbered list of the queue

  m [p|l|m|#[+|-#]] [p|l|m|#[+|-#]] [s #|v] [x #] [r #]
  		move entry. l means last, p means currently playing, m means a position mark
		set with passing s #. set mark by passing s # and see current mark with s v.
		pass x # to move # to the position of the queue selected in the fzf window
		that will pop up. pass r to remove; can specify a range to delete
		by passing start,end (separated by comma). you can use p|l|m for all of 'm s|x|r'.
		examples: ytmp m 10 2; ytmp m s 123; ytmp m m +5; ytmp m p+3 l-1; ytmp x p-2;
		ytmp m r p+2,l-15 l-5 10

  E 		edit the queue in nvim and source rc from "$XDG_CONFIG_HOME/nvim/ytmp.vim"

  -sd <#> 	get listen history and other details about entry (accepts p|l|m like 'm')
  -dl 		download song # (accepts p|l|m like 'm'). does not respect \$max_len_for_dl.
  -shuf 	runs shuf on the queue file and overwrites it.

  -vd 		prints /tmp/ytmpqdiscards which contains list of songs that were selected to
  		be added to the queue but were already found on the queue. it's removed with
		every search.

  -rd [c] 	copies or moves songs listed in /tmp/ytmpqdiscards which means songs that were
  		selected to be added to the queue but were already found there; can be copied
		(when given c option) to or moved (when no options are given) from their current
		position to the position they would have been added on if they were never found
		on the queue.

  -d [<start on>] [[[<from>] [<to>]] [k]]
		run daemon to play one song after another or if a range is specified with two args
		then loop in that range unless 'k' is specified in which case exit after reaching
		the end of range. there's no way to remove the range; if you want it to continue
		playing beyond it, run it again without the range. also optionally accepts
		an entry # to start playing from (if another song is playing, it will wait
		for it to end to start playing from the entry provided)
		(kills any other instances of -r or -d running on start.)

  -r [[<from>] [<to>]]
  		play random entries; a range can be specified with two separate arguements.
  		there's no way to remove the range; if you want it to continue play beyond it,
		run it again. (kills any other instances of -r or -d running on start.)

  -n 		get notified when mpv exits (i.e. song finishes)

  -qa 		quit audio
  -kd 		kill daemon
  -kr 		kill the random daemon (-r)
  -ka 		do all of the above

  h|help|-h|--help
  		show this help

  ----------------------------------------------
  fzf bindings for search (ytmp x|s):
  ----------------------------------------------

  	ctrl-j		jump
  	ctrl-r		replace input field with selection
  	ctrl-x		send input field as search (none of the selections are passed)
	ctrl-o:		open entry in web browser
  	enter		search only the selections (query not included)
  	tab		toggle selection and clear query
  	shift-tab	deselect all
  	ctrl-c/esc	quit

  * query+selections are only available as background search due to fzf limitations.
    when you press the binding there isn't any indication that the search has passed through
    so you can assume that fact and just abort fzf.
    also these bindings are unavailalbe or mean different things for x/s:

	ctrl-s		search query in the background
	alt-s		search query and selection in the background
	ctrl-z		search query in counterpart of current search in the background
	alt-z		search query and selection in counterpart of current search in the background

  ----------------------------------------------
  fzf bindings for playlist search (sp):
  ----------------------------------------------

	tab		toggle selection
	shift-tab	deselect all
	enter		add selected playlists to queue

	ctrl-o:		open entry in web browser
	ctrl-x		see songs in the playlist
			one can select songs in the playlist to add with <tab> and press <enter> to add them

  ----------------------------------------------
  fzf bindings for viewing queue (v|vv):
  ----------------------------------------------

	home:		first and reload
	end:		last and reload
	shift-up:	move entry up one
	shift-down:	move entry down one
	shift-right:	play entry and don't exit fzf window
	shift-left:	delete entry
	page-up:	move entry to after currently playing
	page-down:	move entry to before currently playing
	enter:		play entry and quit fzf
	alt-m:		ytmp m
	ctrl-\:		ytmp E
	ctrl-6:		ytmp mln
	ctrl-]:		ytmp w
	alt-v:		up one page
	ctrl-v:		down one page
	ctrl-alt-p:	up half page
	ctrl-alt-n:	down half page
	left-click:	play entry
	right-click:	move entry to after currently playing
	ctrl-j:		jump
	ctrl-s:		search query in background
	ctrl-z:		search query in background with ytmp z
	ctrl-r:		replace input field with selection
	ctrl-alt-d:	download selection
	alt-r:		reload queue
	ctrl-o:		open entry in web browser
	alt-up:		move entry to first
	alt-down:	move entry to last
	alt-n:		play next song
	alt-p:		play prev song
	ctrl-alt-m:	set entry as mark (for 'm' option)
	ctrl-space:	move entry to the selected position in a new fzf search

  ----------------------------------------------
  nvim key bindings:
  ----------------------------------------------

	mapleader 	'<Space>'
	leader-v 	source $XDG_CONFIG_HOME/nvim/init.vim
	leader-s 	source $XDG_CONFIG_HOME/nvim/ytmp.vim
	leader-c 	edit $XDG_CONFIG_HOME/nvim/ytmp.vim
	leader-n 	edit $USER/Music/ytmp/run_on_nextZ

	up 		move entry up 1
	down 		move entry down 1
	left 		move entry right before currently playing
	right 		move entry right next to currently playing
	shift-Up 	move last entry right before currently playing
	shift-Down 	move last entry right after currently playing
	shift-Right 	move entry to the end
	shift-Left 	move entry to the start
	enter 		play entry

	d 		delete line
	r 		reload file
	R 		remove *** from line
	W 		write file
	J 		go to currently playing
	> 		play next
	< 		play previous
	. 		-sd for entry
	o 		open entry in web browser

	ctrl-t 		:te
	ctrl-y 		:te ytmp
	ctrl-w 		:te ytmp z
	ctrl-s 		:te ytmp v
	ctrl-v 		:te ytmp vv
	ctrl-p 		:silent !ytmpsuite qs
	ctrl-n 		:silent !ytmpsuite qn

	leader-v 	change the value of the \$vol var in the run_on_next file
	leader-l 	set volume of what's currently playing
	leader-w 	ytmp w
	leader-y 	:silent !ytmp

  ----------------------------------------------

Other features:
  - One can communicate with mpv through the ipc socket the script opens at /tmp/mpvsocketytmp.
  	See https://pastebin.com/23PXxpiD for examples (make sure to pass commands to the
	/tmp/mpvsocketytmp socket) and \`mpv --list-properties\` for properties that can be controlled.
  - you can have multiple entries of the same song in multiple places and the program won't get confused
  	(in case you wanted to move tracks of albums around without changing their place in the album).
  - by default ytmp downloads songs after you have listened to them $max_stream_amount times,
  	if you don't want this feature set \$download_songs to '0' in $conf. the downloads can be found
	in $songs_dir.
  - put commands you want to run at the start of each song in the script $run_on_next.
  - set settings in $conf.

You might be interested to know:
  - songs are downloaded with the 'bestaudio' option
  - mpv is started with these options: --x11-name='ytmp_mpv' --no-terminal --vid=no --input-ipc-server=/tmp/mpvsocketytmp
  - readline commands/binds are available in all fzf instances
  - <search> with spaces don't have to be quoted
  - when allowed to multi-select in fzf, if no selections are made and enter is pressed, the entry under
  	the cursor is sent; if selections are made only the selections are passed
  - entries for local files are created with \`cksum --untagged --algorithm=blake2b -l 48 <file> | sed 's@\b  @ @'\`
  - the editor config is made for nvim; not all binds are tested to be working in vim
  - thumbnails are not automatically deleted. if \$download_thumbnails option is set to 1 then thumbnails are
	downloaded and not removed regardless of whether the song is downloaded or not
  - artists are only parsed for in a song if the search is made with no args or 's'
  - sadly there's no way to customize the fzf keybinds without modifying the source so if something doesn't
	work for you feel free to do a global replace of the bind (the keynames are what's shown in this help).
  - also unfortunately the program does not check and will not tell you if you've entered something unexpected/wrong
	or do not have all the dependencies installed
CAT_EOF
exit
}

# adds entries to queue while scanning to see if entry is already in the queue;
# if it is, doesn't add to the queue but notes where the id is found in the queue,
# the length of the queue, <id>, <title> in /tmp/ytmpqdiscards so the user can be given a choice
# later to move or copy the entry at the position it would appear as if it weren't in the queue
addToQueue () {
	touch "$qdiscards_file"
	if [ "$1" = 'f' ]; then
		id="$( echo "$2" | cut -d' ' -f1 )"
		title="$( echo "$2" | cut -d' ' -f2- )"
	else
		id="$1"
		title="$2"
	fi

	if ( ! grep -Fq "$id" "$queue" ); then
		echo "$id $title" >> "$queue"
		echo "Added '$title'"
	else
		found="$( grep -n "$id" "$queue" | cut -d':' -f1 )"
		echo "'$title' was found at line $found in the queue. It will not be newly added."
		queue_len="$( grep -c '' "$queue" )"
		echo "$queue_len $id $title" >> "$qdiscards_file"
	fi
}

# copies or moves entries from $qdiscards_file
transferQDiscards () {
	[ ! -s "$qdiscards_file" ] && echo "'$qdiscards_file' either doesn't exist or is empty." && return
	[ "$1" = 'v' ] && cat "$qdiscards_file" && return

	if [ "$1" = 'c' ]; then
		ed_opt='t'
		action='Copied'
	else
		ed_opt='m'
		action='Moved'
	fi

	rm /tmp/ytmpplaces
	# record the entries that are in where the entries should be moved to
	cat "$qdiscards_file" | while read -r f; do
		sed -n "$( echo "$f" | cut -d' ' -f1 )"p "$queue" >> /tmp/ytmpplaces
	done

	x="$( grep -c '' /tmp/ytmpplaces )"
	# read lines in from bottom to top (tac) in case multiple entries
	# are competing for the same spot
	# get all the lines that are at $place and then /$place/; don't directly move
	# because as the lines are moved around, the order is destroyed
	cat "$qdiscards_file" | tac | while read -r f; do
		id="$( echo "$f" | cut -d' ' -f2 )"
		found="$( grep -n "$id" "$queue" | cut -d':' -f1 )"
		place="$( sed -n "${x}s/$field_regex/\1/p" /tmp/ytmpplaces )"
		old_found="$( grep -n "$id" "$queue" | head -1 )"
		printf "%s\n" "/$place/" "${found}${ed_opt}." "wq" | ed -s "$queue" >/dev/null
		x=$(( x-1 ))
		place="$( grep -n "$place" "$queue" | head -1 )"
		found="$( grep -n "$id" "$queue" | head -1 )"
		echo "$action [$( echo "$old_found" | cut -d':' -f1 )] '$( echo "$f" | cut -d' ' -f3- )' [[TO AFTER]] [$( echo "$place" | cut -d':' -f1 )] '$( echo "$place" | cut -d' ' -f2- )'"
	done | tac
	printf "\nNOTE: The line numbers displayed may be inaccurate due to things having been moved about."
}

# gets the artists listed in the description and places them in $played_artists if first time seeing $id. artists are usually separated by '·' and ':'. also puts things in the queue file.
register () {
	id="$1"
	[ -n "$2" ] && title="$2" || title=$( yt-dlp -q --no-warnings -e "https://www.youtube.com/watch?v=$id" )
	dt="$( date +'%m/%d/%y+%T' )"
	rm -f "$qdiscards_file"

	if ( ls "$songs_dir"/*"${id}"* >/dev/null 2>&1 ); then addToQueue "$id" "$title";
	elif ! grep -Fq "$id" "$played_urls"; then
		desc=$( yt-dlp -q --no-warnings --get-description "https://www.youtube.com/watch?v=$id" )
		echo "$title" >> "$played_titles"
		# this empty entry is added so the program knows it has seen the id before
		# and parsed its description for artists already so it doesn' prase it again
		# in the future
		echo "$id 0 $dt $title" >> "$played_urls"
		if ( echo "$desc" | grep -q 'Auto-generated by YouTube\.$' ); then
			if ( echo "$desc" | grep -q '·' ); then
				artist=$( echo "$desc" | grep '·' | sed -e 's/^[^·]*·//g' -e 's/·/\\\n/g' -e 's/\\//g' | xargs -0 printf '%b' )
				echo "$artist" | while read -r f; do
					if ! grep -q "$f" "$played_artists"; then
						echo "$f" >> "$played_artists"
					fi
				done
			fi
			if ( echo "$desc" | grep -q ':' ); then
				artist="$( echo "$desc" | sed -e  '/.*:/!d' -e 's/.*://p' | sed -e '/\./d' -e '/[0-9]/d' -e 's/\\//g' | sort -u )"
				echo "$artist" | while read -r f; do
					if ! grep -q "$f" "$played_artists"; then
						echo "$f" >> "$played_artists"
					fi
				done
			fi
		fi
		addToQueue "$id" "$title"
	else addToQueue "$id" "$title"; fi
}

# add urls, playlists, dirs, paths
add () {
	shift 1
	[ -z "$1" ] && echo 'Provide a url, path, or directory to add as arguement' && return

	rm -f "$qdiscards_file"
	for f in "$@"; do
		if echo "$f" | grep -q 'http.*\.com'; then
			ids="$( yt-dlp -q --no-warnings --get-id "$f" )"
			echo "$ids" | while read -r id; do
				title=$( yt-dlp -q --no-warnings -e "https://www.youtube.com/watch?v=$id" )
				addToQueue "$id" "$title"
			done
		elif [ -d "$f" ]; then
			find "$f" | sed 1d | while read -r f; do
				entry="$( cksum --untagged --algorithm=blake2b -l 48 "$f" | sed 's@\b  @ @' )"
				addToQueue f "$entry"
			done
		elif [ -e "$f" ]; then
			entry="$( cksum --untagged --algorithm=blake2b -l 48 "$f" | sed 's@\b  @ @' )"
			addToQueue f "$entry"
		else
			echo "'$f' is not valid; provide a url, path, or directory."
		fi
	done
}

searchSongs () {
	# ss = <query> was passed from cli
	if [ "$1" = 'ss' ]; then
		query=$( echo "$*" | cut -d' ' -f2- | tr "\n" ' ' | sed -e 's/[ \t]*$//' )
	# p = playlist url
	elif [ "$1" = 'p' ]; then
		query="$2"
	elif [ "$1" = 'z' ] && [ -n "$3" ]; then
		query="$( echo "$@" | cut -d' ' -f3- )"
	else
		songs_dir_ls=$( ls "$songs_dir" | cut -d' ' -f2- | sed 's/\.webm$//' )
		entries=$( cat "$search_history" "$played_titles" "$played_artists" )
		query=$( echo "$entries $songs_dir_ls" | fzf --prompt='search: ' --info=inline --padding=2,2,2,2 --border=bottom --color=gutter:black,hl+:bold:bright-red,hl:bright-red,label:italic:white,marker:cyan,pointer:cyan,bg+:black,label:white,info:white:dim,label:white:dim,spinner:white:dim --border-label-pos=3 --border-label="{   ytmp search   }" --separator='' \
		--layout=reverse --height 60% -m --bind='ctrl-j:jump,ctrl-k:kill-line,tab:toggle+clear-query+down,shift-tab:clear-selection,ctrl-z:execute-silent(setsid -f ytmp z {q}),alt-z:execute-silent(setsid -f ytmp z {+} {q} ),alt-s:execute-silent(setsid -f ytmp {+} {q}),tab:select+clear-query,return:accept,ctrl-r:replace-query,ctrl-x:print-query,ctrl-s:execute-silent(setsid -f ytmp {q})' | tr "\n" ' ' | sed -e 's/[ \t]*$//' )
	fi

	if [ -n "$query" ]; then [ "$1" != 'p' ] && echo "Searching for '$query'"; else return; fi

	( ! grep -Fxq "$query" "$search_history" ) && ( ! echo "$songs_dir_ls" | grep -Fq "$query" ) && echo "$query" >> "$search_history"
	rm -f "$qdiscards_file"

	# allows user to browse search results and select
	if [ "$1" = 'p' ] || [ "$1" = 'x' ] || [ "$1" = 's' ]; then
		if [ "$1" = 'x' ]; then
			printf "$2" | grep -xq '[0-9]*' && ids_titles=$( yt-dlp -q --no-warnings -e --get-id ytsearch"${2}":"$query" ) || ids_titles=$( yt-dlp -q --no-warnings --get-id -e ytsearch5:"$query" )
		elif [ "$1" = 'p' ]; then
			url="$( sed -n "${query}s/ .*//p" /tmp/ytmpplaylists )"
			ids_titles=$( pipe-viewer --no-interactive --no-use-colors --results=50 --custom-layout="*TITLE*\n*ID*" -e="*ID* *TITLE*" "$url" | sed 1d )
		else
			printf "$2" | grep -xq '[0-9]*' && ids_titles=$( yt-dlp -q --no-warnings --get-id -e ytsearch"${2}":"$query auto-generated provided to youtube" ) || ids_titles=$( yt-dlp -q --no-warnings --get-id -e ytsearch5:"$query auto-generated provided to youtube" )
		fi

		# separates ids and titles. shows only $titles to user and then uses the number of the line $title is found on
		# to get the correct id.
		ids=$( echo "$ids_titles" | sed -n 'n;p' )
		echo "$ids" > /tmp/ytmpids
		titles=$( echo "$ids_titles" | sed -n 'p;n' | grep -n '' )
		sel=$( printf '%b' "$titles" | fzf --prompt='search: ' --info=inline --padding=2,2,2,2 --border=bottom --color=gutter:black,hl+:bold:bright-red,hl:bright-red,label:italic:white,marker:cyan,pointer:cyan,bg+:black,label:white,info:white:dim,label:white:dim,spinner:white:dim --border-label-pos=3 --border-label="{   ytmp select   }" --separator='' \
		--bind='ctrl-o:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp openInBrowser id ,,),ctrl-j:jump,ctrl-k:kill-line,tab:toggle+clear-query+down,shift-tab:clear-selection' --layout=reverse --height 60% -m --preview='echo {n}+1 | bc | xargs -I ,, ytmp fzfPreview s ,,' --preview-window='right,70%' )
		[ -z "$sel" ] && return
		echo "$sel" | while read -r sel; do
			num=$( printf '%b' "$titles" | grep -Fx "$sel" | cut -d':' -f1 )
			id=$( printf '%b' "$ids" | sed -n "${num}"p )
			[ "$1" = 's' ] && register "$id" "$( echo "$sel" | cut -d':' -f2- )" || addToQueue "$id" "$( echo "$sel" | cut -d':' -f2- )"
		done
	elif [ -n "$query" ]; then
		if [ "$1" = 'z' ]; then
			id=$( yt-dlp -q --no-warnings --get-id ytsearch1:"$query" )
			addToQueue "$id" "$( yt-dlp -q --no-warnings -e "https://www.youtube.com/watch?v=$id" )"
		else
			id=$( yt-dlp -q --no-warnings --get-id ytsearch1:"$query auto-generated provided to youtube" )
			[ -n "$id" ] && register "$id"
		fi
	fi
}

searchPlaylists () {
	[ -z "$2" ] && echo 'Provide a search string as arguement.' && return
	query=$( echo "$*" | cut -d' ' -f2- )
	playlist_sel="$( pipe-viewer --no-use-colors --no-interactive --results=50 -sp --custom-playlist-layout='*URL* *TITLE*' "$query" | sed -n -e 1d -e "\@https://www.youtube.com/playlist?list=@p" | tee /tmp/ytmpplaylists | cut -d" " -f2- | grep -n '' | fzf --prompt='search: ' --info=inline --padding=2,2,2,2 --border=bottom --color=gutter:black,hl+:bold:bright-red,hl:bright-red,label:italic:white,marker:cyan,pointer:cyan,bg+:black,label:white,info:white:dim,label:white:dim,spinner:white:dim --border-label-pos=3 --border-label="{   ytmp playlist select   }" --separator='' \
		--layout=reverse --height 60% -m --bind='ctrl-o:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp openInBrowser pl ,,),ctrl-j:jump,home:first,end:last,ctrl-k:kill-line,shift-tab:clear-selection,tab:toggle+down,ctrl-x:execute(echo {n}+1 | bc | xargs -I ,, ytmp spr p ,,)' --preview='echo {n}+1 | bc | xargs -I ",," sed -n ,,p /tmp/ytmpplaylists | xargs -0 -I ",," pipe-viewer --no-use-colors --results=50 --custom-layout="*AUTHOR* *TIME* *TITLE*" --no-interactive ",," | sed 1d' | grep '^[0-9]*:' )"

	[ -z "$playlist_sel" ] && return
	printf "Adding:\n${lsp}$playlist_sel\n${lsp}"
	printf "yt-dlp is a little slow retrieving things, give it some time to add everything.\n${lsp}"

	echo "$playlist_sel" | while read -r s; do
		num="$( printf '%b' "$s" | cut -d':' -f1 )"
		url="$( sed -n "${num}"p /tmp/ytmpplaylists | cut -d' ' -f1 )"
		add a "$url"
	done
}

# ticks up the amount a song has been played by one. $played_urls has the format: id amount_played date_played 'dl'(if downloaded) title
# also downloads the file once it exceeds $max_stream_amount and it can't be found in the $songs_dir
incrAmntPlayed () {
	[ -n "$1" ] && id="$1" || id=$( grep "$playing_regex" "$queue" | cut -d' ' -f1 )
	[ -n "$2" ] && title=$( echo "$*" | cut -d' ' -f2- ) || title=$( sed -n -e "/$playing_regex/s/$playing_marker_regex//" -e 's/\*\*\*$//p' "$queue" )
	dt="$( date +'%m/%d/%y+%T' )"
	amnt_played="$( grep -F "$id" "$played_urls" | head -1 | cut -d' ' -f2 )"
	amnt_played=$((amnt_played + 1))
	sed -i "/$id/d" "$played_urls"
	[ "$( printf "$id" | wc -m )" = '12' ] && echo "$id $amnt_played $dt $title" >> "$played_urls" && return
	[ -z "$id" ] && return
	if [ $download_songs = "1" ] && [ "$amnt_played" -gt "$max_stream_amount" ]; then
		if ( ls "$songs_dir"/*"${id}"* >/dev/null 2>&1 ); then
			echo "$id $amnt_played $dt dl $title" >> "$played_urls"
		else
			len=$( yt-dlp -q --no-warnings --get-duration "https://www.youtube.com/watch?v=$id" | sed -E 's/(.*):(.+):(.+)/\1*3600+\2*60+\3/;s/(.+):(.+)/\1*60+\2/' | bc )
			[ "$len" -lt $max_len_for_dl ] && ( [ "$notifications" = '1' ] && notify-send "Downloading '${title}.' You have listened to it $amnt_played times. Playback will start once download finishes."; echo "Downloading '${title}.' You have listened to it $amnt_played times. Playback will start once download finishes." && yt-dlp -q --no-warnings -f bestaudio -o "$songs_dir/%(id)s %(title)s.%(ext)s" "https://www.youtube.com/watch?v=$id" >/dev/null 2>&1 && echo "$id $amnt_played $dt dl $title" >> "$played_urls" ) || echo "$id $amnt_played $dt $title" >> "$played_urls"
		fi
	else
		ls "$songs_dir"/*"${id}"* >/dev/null 2>&1 && echo "$id $amnt_played $dt dl $title" >> "$played_urls" || echo "$id $amnt_played $dt $title" >> "$played_urls"

	fi
}

dlThumbnail () {
	if [ "$download_thumbnails" = '1' ]; then
		id=$( sed -n "s/$playing_regex/\1/p" "$queue" )
		[ "$( printf "$id" | wc -m )" != '11' ] && return
		if ( ! ls "$thumb_dir"/*"${id}"* >/dev/null 2>&1 ); then
			title=$( sed -n -e "/$playing_regex/s/$playing_marker_regex//" -e 's/\*\*\*$//p' "$queue" )
			yt-dlp -q --no-warnings --get-thumbnail "https://www.youtube.com/watch?v=$id" | xargs curl --output "$thumb_dir/$id $title.webp"
			ln -fs "$thumb_dir"/*"${id}"* /tmp/muscover.webp
		else
			ln -fs "$thumb_dir"/*"${id}"* /tmp/muscover.webp
		fi
	fi
}

# plays the $id passed to it. if no arguements, it sets id to whatever is surrounded by ***
play () {
	[ -n "$1" ] && id="$1" || id=$( sed -n "s/$playing_regex/\1/p" "$queue" )
	[ -z "$id" ] && return
	# if the length of id (first field) is 12 then it is a checksum of a local file and not a youtube id so play it and exit
	if [ "$( printf "$id" | wc -m )" = '12' ]; then
		setsid -f mpv --x11-name='ytmp_mpv' --no-terminal --vid=no --input-ipc-server=/tmp/mpvsocketytmp "$( sed -n -e "/$id/s/$playing_marker_regex//" -e 's/\*\*\*$//p' "$queue" )"
		incrAmntPlayed
		return
	fi
	incrAmntPlayed "$id"
	if ( ls "$songs_dir"/*"${id}"* >/dev/null 2>&1 ); then
		find "$songs_dir"/*"${id}"* -print0 | xargs -0 -I ',,' setsid -f mpv --x11-name='ytmp_mpv' --no-terminal --vid=no --input-ipc-server=/tmp/mpvsocketytmp ",,"
		dlThumbnail
	else
		setsid -f mpv --x11-name='ytmp_mpv' --no-terminal --vid=no --input-ipc-server=/tmp/mpvsocketytmp --ytdl-format='bestaudio' "https://www.youtube.com/watch?v=$id"
		dlThumbnail
	fi
	title="$( sed -n -e "/$playing_regex/s/$playing_marker_regex//" -e 's/\*\*\*$//p' "$queue" )"
	echo "Playing '$title'"
	[ "$notifications" = '1' ] && notify-send 'Now Playing' "$title"
	setsid -f sh "$run_on_next" >/dev/null 2>&1
	[ "$daemonize" = 1 ] && ! pgrep -fa 'ytmp -d' && setsid -f ytmp -d >/dev/null 2>&1
}

# puts stars around line # and removes stars from any other lines
markAsPlaying () {
	line="$1"
	[ -z "$line" ] && return
	line="$( echo "$line" | sed -e s/m/"$( cat /tmp/ytmpmark )"/ -e s/p/"$( grep -n "$playing_regex" "$queue" | head -1 | cut -d':' -f1 )"/ -e s/l/"$( grep -c '.' "$queue" )"/ | bc )"
	lncount=$( grep -c '.' "$queue" )
	if [ "$line" -le 0 ] || [ "$line" -gt "$lncount" ]; then line=1; fi
	sed -i -e "/$playing_regex/s/$playing_marker_regex/\1 /" -e 's/\*\*\*$//' "$queue"
	sed -i "${line}s/${field_regex}/\1 \*\*\*\2\*\*\*/" "$queue"
	echo quit | socat - /tmp/mpvsocketytmp >/dev/null 2>&1
	play
}

# checks if queue is not empty but nothing is playing, it will set stars around the first line and call play
# it also checks if mpv is closed then it calls markAsPlaying p+1 (ytmp n) to play the next entry
daemon () {
	shift 1
	if [ -n "$1" ] && [ -z "$2" ]; then ytmp -n && markAsPlaying "$1"; fi
	if [ -z "$2" ] && ( ! pgrep -fa 'mpv.*--input-ipc-server=/tmp/mpvsocketytmp' >/dev/null 2>&1 ); then markAsPlaying 1; fi
	while true; do
		if [ "$( grep -c '.' "$queue" )" -gt 0 ]; then
			if [ -n "$2" ]; then
				# counts how many times songs outside of the range have been played
				beyond_range=0
				counter="$1"
				! pgrep -fa 'mpv.*--input-ipc-server=/tmp/mpvsocketytmp' >/dev/null 2>&1 && markAsPlaying "$counter"
				while true; do
					while true; do ( ! pgrep -fa 'mpv.*--input-ipc-server=/tmp/mpvsocketytmp' >/dev/null 2>&1 ) && sleep .5 && break; done
					# if the song didn't end and it was the user who changed the song (evidenced
					# by another mpv being spawned immediately after) then note it
					if pgrep -fa 'mpv.*--input-ipc-server=/tmp/mpvsocketytmp' >/dev/null 2>&1; then
						beyond_range=$(( beyond_range+1 ))
						# increment counter only once regardless of how many times songs
						# outside the range have been played.
						[ "$beyond_range" = '1' ] && counter=$(( counter+1 ))
						continue
					fi

					beyond_range=0
					playing="$( grep -n "$playing_regex" "$queue" | cut -d':' -f1 )"
					# if things are outside the range ...
					if [ "$playing" -lt "$1" ] || [ "$playing" -ge "$2" ]; then
						if [ "$counter" -ge "$2" ] && [ "$3" != 'k' ]; then
							markAsPlaying $1
							counter=$1
						else
							markAsPlaying $counter
						fi
					else markAsPlaying p+1; counter=$playing; fi
					counter=$(( counter+1 ))

					if [ "$playing" = "$2" ]; then
						[ "$3" = 'k' ] && return || counter="$1"
					fi
				done
			else
				# sleep twice in case in between the sleeps some external cmd plays something so there
				# is no clash between the two
				sleep 1 && ( ! pgrep -fa 'mpv.*--input-ipc-server=/tmp/mpvsocketytmp' >/dev/null 2>&1 ) && sleep 1 && ( ! pgrep -fa 'mpv.*--input-ipc-server=/tmp/mpvsocketytmp' >/dev/null 2>&1 ) && markAsPlaying p+1
			fi
		else sleep 1; fi
	done
}

# presents an fzf list of the current queue.
viewQueue () {
	[ "$2" = 'p' ] && set -- --height 100% --preview='echo {n}+1 | bc | xargs -I ,, ytmp fzfPreview vv ,,' --preview-window='right,50%' --preview-label='' --bind='focus:transform-preview-label:echo {n}+1 | bc' || set -- --height 60%
	cmd="cat $queue | cut -d' ' -f2-"
	cat "$queue" | cut -d' ' -f2- | fzf --pointer='_' --tiebreak=chunk,begin --prompt='search: ' --info=inline --border=bottom --color=gutter:black,hl+:bold:bright-red,hl:bright-red,label:italic:white,marker:cyan,pointer:cyan,bg+:black,label:white,info:white:dim,label:white:dim,spinner:white:dim --border-label-pos=3 --border-label="{   ytmp queue   }" --separator='' --padding=2,2,2,2 \
	"$@" \
	--layout=reverse --cycle --bind="ctrl-space:execute(echo {n}+1 | bc | xargs -I ,, ytmp m x ,,)+reload($cmd),ctrl-alt-m:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp m s ,,),alt-up:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp m ,, 0)+reload($cmd),alt-down:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp m ,, l)+reload($cmd),ctrl-]:execute-silent(ytmp w),ctrl-r:replace-query,home:first+reload($cmd),end:last+reload($cmd),alt-r:reload($cmd),ctrl-alt-d:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp -dl ,,),ctrl-z:execute-silent(setsid -f ytmp z {q}),ctrl-s:execute-silent(setsid -f ytmp {q}),ctrl-j:down,ctrl-j:jump,shift-left:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp m r ,,)+reload($cmd),shift-up:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp m ,, -2)+reload($cmd)+up,shift-down:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp m ,, +1)+reload($cmd)+down,ctrl-k:kill-line,alt-p:execute-silent(ytmp p)+reload($cmd),alt-n:execute-silent(ytmp n)+reload($cmd),alt-right:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp e ,,)+reload($cmd),return:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp e ,,)+abort,shift-right:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp e ,,)+reload($cmd),pgdn:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp m ,, p)+reload($cmd),pgup:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp m ,, p-1)+reload($cmd),ctrl-v:page-down,alt-v:page-up,ctrl-alt-p:half-page-up,ctrl-alt-n:half-page-down,left-click:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp e ,,)+abort,right-click:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp m ,, p)+reload($cmd),ctrl-^:execute-silent(ytmp mln)+reload($cmd),ctrl-\:execute(ytmp E)+reload($cmd),alt-m:execute(echo {n}+1 | bc | xargs -I ,, ytmp m f ,,)+reload($cmd),ctrl-o:execute-silent(echo {n}+1 | bc | xargs -I ,, ytmp openInBrowser ,,)"
}

# move, remove, set marks.
move () {
	shift 1
	if [ "$1" = 'r' ]; then
		shift 1
		for f in "$@"; do
			if echo "$f" | grep -q ','; then
				start="$( echo "$f" | cut -d',' -f1 )"
				end="$( echo "$f" | cut -d',' -f2 )"
				start="$( echo "$start" | sed -e s/m/"$( cat /tmp/ytmpmark )"/ -e s/p/"$( grep -n "$playing_regex" "$queue" | head -1 | cut -d':' -f1 )"/ -e s/l/"$( grep -c '.' "$queue" )"/ | bc )"
				end="$( echo "$end" | sed -e s/m/"$( cat /tmp/ytmpmark )"/ -e s/p/"$( grep -n "$playing_regex" "$queue" | head -1 | cut -d':' -f1 )"/ -e s/l/"$( grep -c '.' "$queue" )"/ | bc )"
				printf "${start}${end}" | grep -xq '[0-9]*' && printf '%b' "${lsp}Removing from $start to $end\n" && sed -n "${start},${end}s/$field_regex/Removed '\2'/p" "$queue" && printf "$lsp" && sed -i "${start}","${end}"d "$queue"
			else
				f="$( echo "$f" | sed -e s/m/"$( cat /tmp/ytmpmark )"/ -e s/p/"$( grep -n "$playing_regex" "$queue" | head -1 | cut -d':' -f1 )"/ -e s/l/"$( grep -c '.' "$queue" )"/ | bc )"
				printf "$f" | grep -xq '[0-9]*' && echo "Removed [$f] '$( sed -n "${f}s/$field_regex/\2/p" "$queue" )'" && sed -i "${f}"d "$queue"
			fi
		done
		return
	fi
	if [ "$1" = 's' ]; then
		[ "$2" = 'v' ] && cat /tmp/ytmpmark && return
		echo "$2" | sed -e s/m/"$( cat /tmp/ytmpmark )"/ -e s/p/"$( grep -n "$playing_regex" "$queue" | head -1 | cut -d':' -f1 )"/ -e s/l/"$( grep -c '.' "$queue" )"/ | bc > /tmp/ytmpmark
		return
	fi
	if [ "$1" = 'f' ]; then
		sel="$2"
		printf "\nMove entry #$sel to where? "
		read place </dev/tty
	elif [ "$1" = 'x' ]; then
		sel="$( echo "$2" | sed -e s/m/"$( cat /tmp/ytmpmark )"/ -e s/p/"$( grep -n "$playing_regex" "$queue" | head -1 | cut -d':' -f1 )"/ -e s/l/"$( grep -c '.' "$queue" )"/ | bc )"
		place="$( grep -n '' "$queue" | fzf --info=hidden --border=bottom --color=gutter:black,hl+:bold:bright-red,hl:bright-red,label:italic:white,marker:cyan,pointer:cyan,bg+:black,label:white,info:white:dim,label:white:dim,spinner:white:dim --border-label-pos=3 --border-label="{   Move '$( sed -n "${sel}s/${field_regex}/\2/p" "$queue" )' after what?   }" --separator='' | cut -d':' -f1 )"
	else
		place="$2"
		sel="$1"
	fi

	[ -z "$place" ] && return
	sel="$( echo "$sel" | sed -e s/m/"$( cat /tmp/ytmpmark )"/ -e s/p/"$( grep -n "$playing_regex" "$queue" | head -1 | cut -d':' -f1 )"/ -e s/l/"$( grep -c '.' "$queue" )"/ | bc )"
	echo "$place" | grep -Eqx '(\+|-|\*|/)+[0-9]*' && place="$( echo "${sel}${place}" | bc )" || place="$( echo "$place" | sed -e s/m/"$( cat /tmp/ytmpmark )"/ -e s/p/"$( grep -n "$playing_regex" "$queue" | head -1 | cut -d':' -f1 )"/ -e s/l/"$( grep -c '.' "$queue" )"/ | bc )"

	echo "Moved [$sel] '$( sed -n "${sel}s/${field_regex}/\2/p" "$queue" )' [[TO AFTER]] [$place] '$( sed -n "${place}s/${field_regex}/\2/p" "$queue" )'"

	printf "%s\n" "${sel}m${place}" "wq" | ed -s "$queue" >/dev/null
}

fuzzyPlay () {
	shift 1
	query="$@"
	[ -z "$query" ] && echo 'Provide a string to search as argument.' && return
	match=$( grep -n '' "$queue" | sed -E 's/[Rr]emaster(ed)//g' | fzf --tiebreak=chunk,begin -f "$query" | head -1 | cut -d':' -f1 )
	if [ -n "$match" ]; then markAsPlaying "$match"; else echo 'Match not found.'; fi
	return
}

playFromHistory () {
	[ -z "$1" ] && tail -2 "$played_urls" | head -1 | cut -d' ' -f1 | xargs -I '{}' ytmp P '{}' && return
	if ( echo "$1" | grep -qxE '[0-9]*' ); then
		tail "-$1" "$played_urls" | head -1 | cut -d' ' -f1 | xargs -I '{}' ytmp P '{}'
	elif [ "$1" = 's' ]; then
		cat "$played_urls" | fzf --bind="ctrl-o:execute-silent(echo {} | cut -d' ' -f1 | xargs -I ,, ytmp openInBrowser -id ',,')" --prompt='search: ' --info=inline --border=bottom --color=gutter:black,hl+:bold:bright-red,hl:bright-red,label:italic:white,marker:cyan,pointer:cyan,bg+:black,label:white,info:white:dim,label:white:dim,spinner:white:dim --border-label-pos=3 --border-label="{   ytmp history   }" --separator='' \
		--layout=reverse --height 60% --tac | cut -d' ' -f1 | xargs -I '{}' ytmp P '{}'
	else
		tail -2 "$played_urls" | head -1 | cut -d' ' -f1 | xargs -I '{}' ytmp P '{}'
	fi
}

randomDaemon () {
	while ( while true; do ( ! pgrep -fa 'mpv.*--input-ipc-server=/tmp/mpvsocketytmp' >/dev/null 2>&1 ) && sleep .5 && break; done ); do
		if ( ! pgrep -fa 'mpv.*--input-ipc-server=/tmp/mpvsocketytmp' >/dev/null 2>&1 ); then
			if [ -n "$3" ]; then seq "$2" "$3" | shuf -n 1 | xargs ytmp e
			else grep -c '' "$queue" | xargs seq | shuf -n 1 | xargs ytmp e; fi
		fi
	sleep 3
	done
}

fzfPreview () {
	[ -z "$3" ] && echo 'Provide a line number.' && return
	fzf_index="$( echo "$3" | sed -e s/m/"$( cat /tmp/ytmpmark )"/ -e s/p/"$( grep -n "$playing_regex" "$queue" | head -1 | cut -d':' -f1 )"/ -e s/l/"$( grep -c '.' "$queue" )"/ | bc )"

 	[ "$2" = s ] && id="$( sed -n "${fzf_index}"p /tmp/ytmpids | cut -d" " -f1 )" || id="$( sed -n "${fzf_index}s/${field_regex}/\1/p" "$queue" )"

	if [ "$2" = 'vv' ] || [ "$2" = 'c' ]; then
		entry="$( grep "$id" "$played_urls" | head -1 )"
		last_played="$( echo "$entry" | cut -s -d' ' -f3 )"
		amnt_played="$( echo "$entry" | cut -s -d' ' -f2 )"
		[ -z "$last_played" ] && last_played='Never'
		[ -z "$amnt_played" ] && amnt_played='None'

		if ( ls "$songs_dir"/*"${id}"* >/dev/null 2>&1 ); then dl='\nDownloaded: Yes\n'
		elif [ "$( printf "$id" | wc -m )" != '11' ]; then dl='\n'
		else dl='\nDownloaded: No\n'; fi

		[ "$2" = 'c' ] && echo "[$fzf_index] "$( echo "$entry" | cut -s -d' ' -f4- | sed 's/^dl //' )""
		printf "${lsp}Times Played: ${amnt_played}\nLast Played: ${last_played}${dl}${lsp}"
	fi

	[ "$( printf "$id" | wc -m )" != '11' ] && return

	info="$( yt-dlp -q --no-warnings --output-na-placeholder 'ASDASIDJIASDJIAJDI' --print "${lsp}Name: %(title)s \nAlbum: %(album)s \nArtist(s): %(artist)s \nGenre: %(genre)s \nRelease Year: %(release_year)s \nLength: %(duration_string)s \nUpload Date: %(upload_date>%m/%d/%Y)s \nUploader: %(uploader)s \nURL: %(webpage_url)s \n${lsp}Description:\n${lsp}%(description)s \n$lsp" "https://www.youtube.com/watch?v=$id" )"

	printf "$info" | sed -e '/ASDASIDJIASDJIAJDI/d'
}

dlSong () {
	sel="$( echo "$2" | sed -e s/m/"$( cat /tmp/ytmpmark )"/ -e s/p/"$( grep -n "$playing_regex" "$queue" | head -1 | cut -d':' -f1 )"/ -e s/l/"$( grep -c '.' "$queue" )"/ | bc )"
	[ "$3" = 'f' ] && sel=$(( sel + 1 ))
	# echo $sel && return
	id="$( sed -n "${sel}s/${field_regex}/\1/p" "$queue" )"
	title="$( sed -n "${sel}s/${field_regex}/\2/p" "$queue" )"
	[ "$( printf "$id" | wc -m )" != '11' ] && return
	# echo $id && return
	( ! ls "$songs_dir"/*"${id}"* >/dev/null 2>&1 ) && setsid -f yt-dlp -q --no-warnings -f bestaudio -o "$songs_dir/%(id)s %(title)s.%(ext)s" "https://www.youtube.com/watch?v=$id" >/dev/null 2>&1 && echo "Downloading '${title}.'" || echo "A file of the name '$title' was found in $songs_dir. It will not be downloaded."
}

openInBrowser () {
	if [ "$1" = 'pl' ]; then url="$( sed -n "${2}"p /tmp/ytmpplaylists | cut -d' ' -f1 )"; setsid -f "$BROWSER" "$url" >/dev/null 2>&1; exit
	elif [ "$1" = 'id' ]; then id="$( sed -n "${2}"p /tmp/ytmpids )"
	elif [ "$1" = '-id' ]; then id="$2"
	else id=$( sed -n "${1}s/$field_regex/\1/p" "$queue" ); fi
	setsid -f "$BROWSER" "https://www.youtube.com/watch?v=$id" >/dev/null 2>&1
}

toggleMpvWin () {
	state=$( echo '{ "command": ["get_property", "force-window" ] }' | socat - /tmp/mpvsocketytmp | jq .data )
	[ "$state" = "false" ] && echo '{ "command": ["set_property", "force-window", true ] }' | socat - /tmp/mpvsocketytmp >/dev/null 2>&1 && echo '{ "command": ["keypress", "I"] }' | socat - /tmp/mpvsocketytmp >/dev/null 2>&1 && sleep .5 && echo '{ "command": ["keypress", "O"] }' | socat - /tmp/mpvsocketytmp >/dev/null 2>&1 || echo '{ "command": ["set_property", "force-window", false ] }' | socat - /tmp/mpvsocketytmp >/dev/null 2>&1
}

case "${1}" in
	E) nvim -u "$XDG_CONFIG_HOME/nvim/ytmp.vim" --noplugin +/'\*\*\*.*\*\*\*' "$queue" ;;
	mfn) move 1 p ;;
	mln) move l p ;;
	w) toggleMpvWin ;;
	pf) markAsPlaying 1 ;;
	pl) markAsPlaying l ;;
	v) viewQueue v ;;
	vv) viewQueue v p ;;
	s) searchSongs s "$2" ;;
	z) searchSongs z "$@" ;;
	x) searchSongs x "$2" ;;
	sp) searchPlaylists "$@" ;;
	spr) searchSongs p "$3" ;;
	a) add "$@" ;;
	n) markAsPlaying p+1 ;;
	p) markAsPlaying p-1 ;;
	e) markAsPlaying "$2" ;;
	P) fuzzyPlay "$@" ;;
	l) playFromHistory "$2" ;;
	m) move "$@" ;;
	ls) grep --color=auto -n '' "$queue" ;;
	openInBrowser) openInBrowser "$2" "$3" ;;
	fzfPreview) fzfPreview "$@" ;;
	-sd) fzfPreview a c "$2" ;;
	-shuf) shuf "$queue" -o "$queue" ;;
	-vd) transferQDiscards v ;;
	-rd) transferQDiscards "$2" ;;
	-dl) dlSong "$*" ;;
	-d) pgrep -f 'ytmp (-d|-r)+' | grep -v $$ | xargs kill >/dev/null 2>&1; daemon "$@" ;;
	-r) pgrep -f 'ytmp (-d|-r)+' | grep -v $$ | xargs kill >/dev/null 2>&1; randomDaemon "$*" ;;
	-n) while true; do ( ! pgrep -fa 'mpv.*--input-ipc-server=/tmp/mpvsocketytmp' >/dev/null 2>&1 ) && sleep .5 && exit; done ;;
	-l) echo '{ "command": ["set_property", "loop", true] }' | socat - /tmp/mpvsocketytmp >/dev/null 2>&1 ;;
	-p) echo cycle pause | socat - /tmp/mpvsocketytmp >/dev/null 2>&1 ;;
	-ff) [ -n "$2" ] && echo "{ \"command\": [\"seek\", \"+${2}\", \"exact\"] }" | socat - /tmp/mpvsocketytmp >/dev/null 2>&1 && echo "Seeked forward $2 seconds." || echo 'Provide how many seconds to seek forward.' ;;
	-bb) [ -n "$2" ] && echo "{ \"command\": [\"seek\", \"-${2}\", \"exact\"] }" | socat - /tmp/mpvsocketytmp >/dev/null 2>&1 && echo "Seeked backward $2 seconds." || echo 'Provide how many seconds to seek backward.' ;;
	-qa) echo quit | socat - /tmp/mpvsocketytmp ;;
	-kd) pkill -f 'ytmp -d'; exit ;;
	-kr) pkill -f 'ytmp -r'; exit ;;
	-ka) echo quit | socat - /tmp/mpvsocketytmp; pkill -f 'ytmp (-d|-r)+' ;;
	h|help|-h|--help) helper ;;
	*) searchSongs ss "$*" ;;
esac

[ -z "$1" ] && searchSongs
